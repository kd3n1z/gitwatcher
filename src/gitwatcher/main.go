package main

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/fatih/color"
	"github.com/hashicorp/go-version"
	"gopkg.in/yaml.v3"
)

type GitwatcherConfig struct {
	LogEverything   bool     `yaml:"log-everything"`
	StrictMode      bool     `yaml:"strict-mode"`
	HideStdout      bool     `yaml:"hide-stdout"`
	Interval        uint64   `yaml:"interval"`
	Shell           string   `yaml:"shell"`
	ShellArgs       []string `yaml:"args"`
	CheckForUpdates bool     `yaml:"check-for-updates"`
}

type RepoConfig struct {
	Cmd   string   `yaml:"cmd"`
	Shell string   `yaml:"shell"`
	Args  []string `yaml:"args"`
}

type GithubResp struct {
	TagName string `json:"tag_name"`
	HtmlUrl string `json:"html_url"`
	Assets  []struct {
		DownloadUrl string `json:"browser_download_url"`
		Name        string `json:"name"`
	} `json:"assets"`
}

var BRANCH string = "?" //-ldflags
var COMMIT string = "?" //-ldflags

const VERSION string = "1.4.0"

var childProcess *exec.Cmd

var gwConfig GitwatcherConfig = GitwatcherConfig{Interval: 60, LogEverything: false, StrictMode: false, HideStdout: false, CheckForUpdates: false}

var branchName string

// TODO: webhook-mode
func main() {
	gwConfig.ShellArgs = []string{"-c", "$cmd"}
	gwConfig.Shell = "bash"

	if runtime.GOOS == "windows" {
		gwConfig.ShellArgs = []string{"/C$cmd"}
		gwConfig.Shell = "cmd.exe"
	} else if runtime.GOOS != "linux" && runtime.GOOS != "darwin" {
		logWarning("gitwatcher has not been tested on " + runtime.GOOS + ", use at your own risk")
	}

	cfgPath, err := os.UserConfigDir()

	if err == nil {
		os.MkdirAll(cfgPath, os.ModePerm)
		cfgPath = filepath.Join(cfgPath, "gitwatcher.yml")

		if _, err := os.Stat(cfgPath); err == nil {
			data, err := os.ReadFile(cfgPath)
			if err == nil {
				err = yaml.Unmarshal(data, &gwConfig)

				if err != nil {
					logWarning("config parse error: '" + err.Error() + "'")
				}
			} else {
				logWarning("config read error: '" + err.Error() + "'")
			}
		}
	}

	configPath := filepath.Join(".gitwatcher", "config.yml")

	args := os.Args[1:]

	for i := 0; i < len(args); i++ {
		switch args[i] {
		case "-i", "--interval":
			i += 1
			parsedInterval, err := strconv.ParseUint(args[i], 10, 64)
			if err != nil || parsedInterval <= 0 {
				throwError(args[i] + ": invalid interval")
			}
			gwConfig.Interval = parsedInterval
			break
		case "-h", "--help":
			logInfo("gitwatcher v"+VERSION+"\n\nUsage: gitwatcher [options]\n\t-i --interval <seconds>\t\t Specify pull interval.\n\t-d --hide-stdout <true/false>\t Hides child process's stdout.\n\t-s --strict-mode <true/false>\t Enable strict mode.\n\t-l --log-everything <true/false> Log each action.\n\t-h --help\t\t\t Print usage.\n\t-v --version\t\t\t Print current version.\n\t--config-path\t\t\t Print config path.\n\t--check-for-updates\t\t Check for newer versions on github.\n\t--update\t\t\t Update to a newer version.\n\t--test\t\t\t\t Execute command in config.yml and exit.\n\t--init\t\t\t\t Initialize .gitwatcher/config.yml.", true)
			return
		case "-v", "--version":
			logInfo("gitwatcher v"+VERSION+", "+BRANCH+"/"+COMMIT, true)
			return
		case "-l", "--log-everything":
			if i+1 < len(args) && (args[i+1] == "true" || args[i+1] == "false") {
				i += 1
				gwConfig.LogEverything = args[i] == "true"
			} else {
				gwConfig.LogEverything = true
				logWarning(args[i] + " is deprecated, use '" + args[i] + " true'")
			}
			break
		case "-s", "--strict-mode":
			if i+1 < len(args) && (args[i+1] == "true" || args[i+1] == "false") {
				i += 1
				gwConfig.StrictMode = args[i] == "true"
			} else {
				gwConfig.StrictMode = true
				logWarning(args[i] + " is deprecated, use '" + args[i] + " true'")
			}
			break
		case "--test":
			gwConfig.LogEverything = true
			registerExitHandler()
			restartApp(configPath, true)
			return
		case "--check-for-updates":
			checkForUpdates(false, true)
			return
		case "--update":
			checkForUpdates(true, true)
			return
		case "--config-path":
			logInfo(cfgPath, true)
			return
		case "--init":
			if _, err := os.Stat(".gitwatcher"); err != nil {
				os.Mkdir(".gitwatcher", os.ModePerm)
				logInfo("created .gitwatcher", true)
			}

			if _, err := os.Stat(configPath); err != nil {
				f, _ := os.Create(configPath)
				f.WriteString("# generated by gitwatcher\n\n# default config\ndefault:\n  cmd: echo hello world\n  shell: sh\n  args:\n    - -c\n    - $cmd\n\n# config for '" + runtime.GOOS + "'\n" + runtime.GOOS + ":\n  cmd: echo hello world\n")
				f.Close()
				logInfo("created "+configPath, true)
			}
			return
		case "-d", "--hide-stdout":
			if i+1 < len(args) && (args[i+1] == "true" || args[i+1] == "false") {
				i += 1
				gwConfig.HideStdout = args[i] == "true"
			} else {
				gwConfig.HideStdout = true
				logWarning(args[i] + " is deprecated, use '" + args[i] + " true'")
			}
			break
		default:
			throwError(args[i] + ": invalid option")
		}
	}

	if gwConfig.CheckForUpdates {
		checkForUpdates(false, false)
	}

	cmd := exec.Command("git", "--version")

	var out bytes.Buffer
	cmd.Stdout = &out

	err = cmd.Run()

	if err != nil {
		throwError("'" + err.Error() + "', do you have git installed?")
	}

	logInfo("gitwatcher v"+VERSION+", "+trim(out.String())+"\n\t- pull interval: "+strconv.FormatUint(gwConfig.Interval, 10)+" (seconds)\n\t- platform: "+runtime.GOOS+" ("+gwConfig.Shell+" "+strings.Join(gwConfig.ShellArgs, " ")+")", true)
	if gwConfig.StrictMode {
		logInfo("\t- strict mode: enabled", true)
	}
	if gwConfig.HideStdout {
		logInfo("\t- child's stdout: hidden", true)
	}
	logInfo("\t- log level: everything", false)

	branchName = getCurrentBranchName()

	registerExitHandler()

	firstCheck := true

	for {
		changesAvailable := fetchChanges()

		if changesAvailable {
			updateRepository()
		}

		if changesAvailable || firstCheck {
			logInfo(time.Now().Format("15:04")+" - restarting... ", true)
			restartApp(configPath, false)
		}

		firstCheck = false
		time.Sleep(time.Duration(gwConfig.Interval) * time.Second)
	}
}

func fetchChanges() bool {
	logInfo("executing 'git fetch origin "+branchName+" -v'...", false)

	output, err := executeCommand("git", "fetch", "origin", branchName, "-v")

	if err != nil {
		strictError(err.Error())
		return false
	}

	logInfo("\t'"+output+"'", false)

	remoteHash := getBranchHash("origin/" + branchName)
	localHash := getBranchHash(branchName)

	logInfo("origin/"+branchName+": "+remoteHash+"\n......."+branchName+": "+localHash, false)

	return remoteHash != localHash
}

func updateRepository() bool {
	remoteBranch := "origin/" + getCurrentBranchName()

	logInfo("executing 'git reset --hard "+remoteBranch+"'...", false)

	output, err := executeCommand("git", "reset", "--hard", remoteBranch)

	if err != nil {
		strictError(err.Error())
		return false
	}

	logInfo("\t'"+output+"'", false)

	return true
}

func getBranchHash(branch string) string {
	cmd := exec.Command("git", "rev-parse", branch)
	output, err := cmd.Output()

	if err != nil {
		throwError("unable to get current branch name: " + err.Error())
	}

	return trim(string(output))
}

func getCurrentBranchName() string {
	logInfo("executing 'git rev-parse --abrev-ref HEAD'...", false)

	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	output, err := cmd.Output()

	if err != nil {
		throwError("unable to get current branch name: " + err.Error())
	}

	name := trim(string(output))

	logInfo("\t'"+name+"'", false)

	return name
}

func executeCommand(name string, arg ...string) (string, error) {
	cmd := exec.Command(name, arg...)

	var out bytes.Buffer
	var stdErr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stdErr

	err := cmd.Run()

	outStr := trim(out.String() + trim(stdErr.String()))

	return outStr, err
}

func registerExitHandler() {
	c := make(chan os.Signal)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		logInfo("cleaning up...", false)
		if childProcess != nil {
			killProcessGroup(childProcess.Process.Pid)
		}
		os.Exit(1)
	}()
}

func restartApp(configPath string, testMode bool) {
	tabs := ""
	if !testMode {
		tabs = "\t"
	}
	if _, err := os.Stat(configPath); err == nil {
		if childProcess != nil {
			logInfo(tabs+"killing previous process...", false)

			killProcessGroup(childProcess.Process.Pid)
		}

		logInfo(tabs+"reading '"+configPath+"'...", false)
		data, err := os.ReadFile(configPath)
		if err == nil {
			logInfo(tabs+"parsing...", false)

			parsedCfg := map[string]RepoConfig{}

			err = yaml.Unmarshal(data, &parsedCfg)

			cfg, ok := parsedCfg[runtime.GOOS]

			if !ok {
				cfg, ok = parsedCfg["default"]
			}

			if ok {
				if cfg.Shell == "" {
					cfg.Shell = gwConfig.Shell
					logInfo(tabs+"shell not specified, using '"+gwConfig.Shell+"'", false)
				}
				if len(cfg.Args) == 0 {
					cfg.Args = make([]string, len(gwConfig.ShellArgs))
					logInfo(tabs+"shell args not specified, using ["+strings.Join(gwConfig.ShellArgs, ", ")+"]", false)

					for i := 0; i < len(gwConfig.ShellArgs); i++ {
						cfg.Args[i] = gwConfig.ShellArgs[i]
					}
				}
				if len(cfg.Cmd) > 0 {
					for i := 0; i < len(cfg.Args); i++ {
						cfg.Args[i] = strings.ReplaceAll(cfg.Args[i], "$cmd", cfg.Cmd)
					}

					logInfo(tabs+"executing '"+cfg.Shell+" "+strings.Join(cfg.Args, " ")+"'...\n", false)

					childProcess = exec.Command(cfg.Shell, cfg.Args...)

					if !gwConfig.HideStdout {
						childProcess.Stdout = os.Stdout
						childProcess.Stderr = os.Stderr
					}

					configProcess()

					if testMode {
						err = childProcess.Run()
					} else {
						err = childProcess.Start()
					}

					if err != nil {
						strictError("failed to start: '" + err.Error() + "'")
					}
				} else {
					strictError("config.yml: cmd not specified")
				}
			} else {
				strictError("config.yml: no suitable config found (default | " + runtime.GOOS + ")")
			}
		} else {
			strictError("error reading config.yml: '" + err.Error() + "'")
		}
	} else {
		strictError("config.yml not found")
	}
}

func checkForUpdates(selfUpdate bool, logNotFound bool) {
	resp, err := http.Get("https://api.github.com/repos/KD3n1z/gitwatcher/releases/latest")

	if err != nil {
		throwError(err.Error())
	}

	body, err := io.ReadAll(resp.Body)

	if err != nil {
		throwError(err.Error())
	}

	parsedResp := GithubResp{}

	err = json.Unmarshal(body, &parsedResp)

	resp.Body.Close()

	if err != nil {
		throwError("parse error: '" + err.Error() + "'")
	}

	localV, _ := version.NewVersion(VERSION)
	remoteV, _ := version.NewVersion(parsedResp.TagName)

	if localV.LessThan(remoteV) {
		if selfUpdate {
			logInfo("Updating...", true)

			if runtime.GOOS == "windows" {
				throwError("not supported on windows")
			}

			updateUrl := ""

			cOS := runtime.GOOS
			cArch := runtime.GOARCH
			if cOS == "darwin" {
				cOS = "macos"
			}
			if cArch == "amd64" {
				cArch = "x64"
			}

			for _, asset := range parsedResp.Assets {
				fName := strings.ToLower(asset.Name)
				if fName == cOS+".zip" || fName == cOS+"-"+cArch+".zip" {
					updateUrl = asset.DownloadUrl
					break
				}
			}

			if updateUrl == "" {
				throwError("asset " + cOS + "-" + cArch + ".zip not found")
			}

			logInfo("\tcreating temp file...", true)

			file, err := os.CreateTemp("", "gwr-update-zip")

			zipPath := file.Name()

			logInfo("\t\t"+zipPath, true)

			if err != nil {
				throwError(err.Error())
			}

			logInfo("\tdownloading '"+updateUrl+"'...", true)

			downloadResp, err := http.Get(updateUrl)

			if err != nil {
				throwError(err.Error())
			}

			_, err = io.Copy(file, downloadResp.Body)

			if err != nil {
				throwError(err.Error())
			}

			file.Close()
			downloadResp.Body.Close()

			reader, err := zip.OpenReader(zipPath)

			if err != nil {
				throwError(err.Error())
			}

			logInfo("\tunzipping...", true)
			for _, f := range reader.File {
				if f.Name == "gitwatcher" {
					currentBinPath, err := os.Executable()

					if err != nil {
						throwError(err.Error())
					}

					logInfo("\t\tcreating temp file...", true)
					binFile, err := os.CreateTemp("", "gwr-update-bin")

					binPath := binFile.Name()

					logInfo("\t\t\t"+binPath, true)

					if err != nil {
						throwError(err.Error())
					}

					logInfo("\t\tdecompressing...", true)

					zippedFile, err := f.Open()

					if err != nil {
						throwError(err.Error())
					}

					_, err = io.Copy(binFile, zippedFile)

					if err != nil {
						throwError(err.Error())
					}

					zippedFile.Close()
					binFile.Close()

					logInfo("\t\tmoving "+binPath+" to "+currentBinPath+"...", true)

					err = os.Rename(binPath, currentBinPath)

					if err != nil {
						throwError(err.Error())
					}

					logInfo("\t\tchanging permissions to 755...", true)

					os.Chmod(currentBinPath, 755)

					break
				}
			}

			reader.Close()

			logInfo("\tcleaning up...", true)

			err = os.Remove(zipPath)

			if err != nil {
				throwError(err.Error())
			}

			logInfo("\tdone, try gitwatcher --version", true)
		} else {
			logInfo("Update available!\n\tv"+VERSION+" -> "+parsedResp.TagName+"\n\n"+parsedResp.HtmlUrl, true)
		}
	} else if logNotFound {
		logInfo("Already at the latest version.", true)
	}
}

func trim(str string) string {
	return strings.Trim(str, "\n\t\t ")
}

func logInfo(str string, important bool) {
	if important || gwConfig.LogEverything {
		fmt.Fprintln(os.Stdout, str)
	}
}

func throwError(str string) {
	fmt.Fprintln(os.Stderr, color.RedString("error: ")+str)
	os.Exit(1)
}

func logWarning(str string) {
	fmt.Fprintln(os.Stderr, color.YellowString("warning: ")+str)
}

func strictError(str string) {
	if gwConfig.StrictMode {
		throwError("strict: " + str)
	} else {
		logWarning(str)
	}
}
