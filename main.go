package main

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/fatih/color"
	"github.com/hashicorp/go-version"
	"gopkg.in/yaml.v3"
)

type Config struct {
	Cmd string `yaml:"cmd"`
	Shell string `yaml:"shell"`
	Args []string `yaml:"args"`
}

type GithubResp struct {
    TagName string `json:"tag_name"`
    HtmlUrl string `json:"html_url"`
	Assets []struct {
		DownloadUrl string `json:"browser_download_url"`
		Name string `json:"name"`
	} `json:"assets"`
}

var BRANCH string = "?"; //-ldflags
var COMMIT string = "?"; //-ldflags

const VERSION string = "1.2.2";
var logEverything bool = false;
var strictMode bool = false;
var hideStdout bool = false;

var childProcess *exec.Cmd;


// This is my first program written in go, so it may be unstable. Better use --strict-mode

// TODO: webhook-mode
func main() {
	var configOsPath string = filepath.Join(".gitwatcher", "config-" + runtime.GOOS + ".yml");
	var configPath string = filepath.Join(".gitwatcher", "config.yml");

	var interval uint64 = 60;

	var args[] string = os.Args[1:];

	for i := 0; i < len(args); i++ {
		switch args[i] {
			case "-i", "--interval":
				i += 1;
				parsedInterval, err := strconv.ParseUint(args[i], 10, 64);
				if err != nil || parsedInterval <= 0 {
					logError(args[i] + ": invalid interval");
					return;
				}
				interval = parsedInterval;
				break;
			case "-h", "--help":
				logInfo("gitwatcher v" + VERSION + "\n\nUsage: gitwatcher [options]\n\t-i --interval <seconds>\tSpecify pull interval.\n\t-l --log-everything\tLog each action.\n\t-h --help\t\tPrint usage.\n\t-v --version\t\tPrint current version.\n\t-s --strict-mode\tEnable strict mode.\n\t-d --hide-stdout\tHides child process's stdout.\n\t--check-for-updates\tCheck for newer versions on github.\n\t--update\t\tUpdate to a newer version.\n\t--init\t\t\tInitializes .gitwatcher/config.yml.", true);
				return;
			case "-v", "--version":
				logInfo("gitwatcher v" + VERSION + ", " + BRANCH + "/" + COMMIT, true);
				return;
			case "-l", "--log-everything":
				logEverything = true;
				break;
			case "-s", "--strict-mode":
				strictMode = true;
				break;
			case "--check-for-updates":
				checkForUpdates(false);
				return;
			case "--update":
				checkForUpdates(true);
				return;
			case "--init":
				if _, err := os.Stat(".gitwatcher"); err != nil {
					os.Mkdir(".gitwatcher", os.ModePerm);
					logInfo("created .gitwatcher", true);
				}

				if _, err := os.Stat(configPath); err != nil {
					f, _ := os.Create(configPath);
					f.WriteString("# generated by gitwatcher\n# global-config\ncmd: echo hello world\nshell: sh\nargs:\n - -c\n - $cmd\n");
					f.Close();
					logInfo("created " + configPath, true);
				}

				if _, err := os.Stat(configOsPath); err != nil {
					f, _ := os.Create(configOsPath);
					f.WriteString("# generated by gitwatcher\n# config for '" + runtime.GOOS + "'\ncmd: echo hello world\n");
					f.Close();
					logInfo("created " + configOsPath, true);
				}
				return;
			case "-d", "--hide-stdout":
				hideStdout = true;
				break;
			default:
				logError(args[i] + ": invalid option");
				return;
		}
	}
	
	var shellArgs []string = []string{"-c", "$cmd"};
	var shell string = "sh";

	if runtime.GOOS == "windows" {
		shellArgs = []string{"/C$cmd"};
		shell = "cmd.exe";
	} else if runtime.GOOS != "linux" && runtime.GOOS != "darwin" {
		logWarning("gitwatcher has not been tested on " + runtime.GOOS + ", use at your own risk");
	}

	cmd := exec.Command("git", "--version");

    var out bytes.Buffer;
    cmd.Stdout = &out;

    err := cmd.Run();
	
	if err != nil {
        logError("'" + err.Error() + "', do you have git installed?");
		return;
    }

	logInfo("gitwatcher v" + VERSION + ", " + trim(out.String()) + "\n\t- pull interval: " + strconv.FormatUint(interval, 10) + " (seconds)\n\t- platform: " + runtime.GOOS + " (" + shell + " " + strings.Join(shellArgs, " ")  + ")", true);
	if strictMode {
		logInfo("\t- strict mode: enabled", true);
	}
	if hideStdout {
		logInfo("\t- child's stdout: hidden", true);
	}
	logInfo("\t- log level: everything", false);

	c := make(chan os.Signal);
    signal.Notify(c, os.Interrupt, syscall.SIGTERM);
    go func() {
        <-c
		logInfo("cleaning up...", false);
		if childProcess != nil {
			killProcessGroup(childProcess.Process.Pid);
		}
        os.Exit(1);
    }();

	var firstCheck bool = true;

	for {
		logInfo("executing 'git pull'...", false);
		cmd := exec.Command("git", "pull");

		var out bytes.Buffer;
		var stdErr bytes.Buffer;
		cmd.Stdout = &out;
		cmd.Stderr = &stdErr;

		err := cmd.Run();

		var outStr string = strings.ToLower(trim(out.String()) + trim(stdErr.String()));
		
		if err != nil {
			strictError(err.Error() + ", '" + outStr + "'");
		}
		if strings.HasPrefix(outStr, "fatal:") || strings.HasPrefix(outStr, "error:") {
			strictError("'" + outStr + "'");
		}
		logInfo("\t'" + outStr + "'", false);

		if firstCheck || (outStr != "already up to date." && len(outStr) > 0) {
			logInfo(time.Now().Format("15:04") + " - restarting... ", true);

			var currentConfigPath string = configPath;
	
			if _, err := os.Stat(configOsPath); err == nil {
				currentConfigPath = configOsPath;
			}
	
			if _, err := os.Stat(currentConfigPath); err == nil {
				if childProcess != nil {
					logInfo("\tkilling previous process...", false);

					killProcessGroup(childProcess.Process.Pid);
				}

				logInfo("\treading '" + currentConfigPath + "'...", false);
				data, err := os.ReadFile(currentConfigPath);
				if(err != nil) {
					logError("'" + err.Error() + "'");
					return;
				}
	
				logInfo("\tparsing...", false);
	
				cfg := Config{Shell: shell};
				cfg.Args = make([]string, len(shellArgs));
				for i, value := range shellArgs {
					cfg.Args[i] = value;
				}
				err = yaml.Unmarshal(data, &cfg);
	
				if(err != nil) {
					strictError("parse error: '" + err.Error() + "'");
				}

				for i := 0; i < len(cfg.Args); i++ {
					cfg.Args[i] = strings.ReplaceAll(cfg.Args[i], "$cmd", cfg.Cmd);
				}
				
				logInfo("\texecuting '" + cfg.Shell + " " + strings.Join(cfg.Args, " ") + "'", false);

				childProcess = exec.Command(cfg.Shell, cfg.Args...);

				if !hideStdout {
					childProcess.Stdout = os.Stdout;
					childProcess.Stderr = os.Stderr;
				}
				
				configProcess();

				err = childProcess.Start();
	
				if(err != nil) {
					strictError("failed to start: '" + err.Error() + "'");
				}
			}else{
				strictError("config.yml not found");
			}
		}

		firstCheck = false;
		time.Sleep(time.Duration(interval) * time.Second);
	}
}

func checkForUpdates(selfUpdate bool) {
	resp, err := http.Get("https://api.github.com/repos/KD3n1z/gitwatcher/releases/latest");

	if(err != nil) {
		logError(err.Error());
		return;
	}

	body, err := io.ReadAll(resp.Body);
	
	if(err != nil) {
		logError(err.Error());
		return;
	}

	parsedResp := GithubResp{};

	err = json.Unmarshal(body, &parsedResp);

	resp.Body.Close();
	
	if(err != nil) {
		logError("parse error: '" + err.Error() + "'");
		return;
	}

	localV, _ := version.NewVersion(VERSION);
	remoteV, _ := version.NewVersion(parsedResp.TagName);

	if localV.LessThan(remoteV) {
		if selfUpdate {
			logInfo("Updating...", true);

			if runtime.GOOS == "windows" {
				logError("not supported on windows");
				return;
			}

			var updateUrl string = "";

			var cOS = runtime.GOOS;
			var cArch = runtime.GOARCH;
			if cOS == "darwin" {
				cOS = "macos";
			}
			if cArch == "amd64" {
				cArch = "x64";
			}

			for _, asset := range parsedResp.Assets {
				var fName string = strings.ToLower(asset.Name);
				if fName == cOS + ".zip" || fName == cOS + "-" + cArch + ".zip" {
					updateUrl = asset.DownloadUrl;
					break;
				}
			}

			if(updateUrl == "") {
				logError("asset " + cOS + "-" + cArch + ".zip not found");
				return;
			}

			logInfo("\tcreating temp file...", true);

			file, err := os.CreateTemp("", "gwr-update");

			path := file.Name();

			logInfo("\t\t" + path, true);

			if err != nil {
				logError(err.Error());
				return;
			}

			logInfo("\tdownloading '" + updateUrl + "'...", true);

			downloadResp, err := http.Get(updateUrl);

			if err != nil {
				logError(err.Error());
				return;
			}

			_, err = io.Copy(file, downloadResp.Body);

			if err != nil {
				logError(err.Error());
				return;
			}

			file.Close();
			downloadResp.Body.Close();

			reader, err := zip.OpenReader(path);

			if err != nil {
				logError(err.Error());
				return;
			}

			logInfo("\tunzipping...", true);
			for _, f := range reader.File {
				if f.Name == "gitwatcher" {
					cPath, err := os.Executable();

					if err != nil {
						logError(err.Error());
						return;
					}

					logInfo("\t\topening '" + cPath + "'...", true);
					executable, err := os.OpenFile(cPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode());

					if err != nil {
						logError(err.Error());
						return;
					}

					logInfo("\t\tdecompressing...", true);

					zippedFile, err := f.Open();

					if err != nil {
						logError(err.Error());
						return;
					}

					_, err = io.Copy(executable, zippedFile);

					if err != nil {
						logError(err.Error());
						return;
					}

					zippedFile.Close();
					executable.Close();

					break;
				}
			}

			reader.Close();

			logInfo("\t\tcleaning up...", true);

			err = os.Remove(path);

			if err != nil {
				logError(err.Error());
			}

			logInfo("\tdone, try gitwatcher --version", true);
		}else{
			logInfo("Update available!\n\tv" + VERSION + " -> " + parsedResp.TagName + "\n\n" + parsedResp.HtmlUrl, true);
		}
	}else{
		logInfo("You're using the latest version.", true);
	}
}

func trim(str string)(string) {
	return strings.Trim(str, "\n\t\t ");
}

func logInfo(str string, important bool) {
	if important || logEverything {
		fmt.Println(str);
	}
}

func logError(str string) {
	fmt.Println(color.RedString("error: ") + str);
}

func logWarning(str string) {
	fmt.Println(color.YellowString("warning: ") + str);
}

func strictError(str string) {
	if strictMode {
		logError(str);
		os.Exit(1);
	}else{
		logWarning(str);
	}
}